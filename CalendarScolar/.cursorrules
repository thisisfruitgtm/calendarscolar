# CalendarScolar - Code Standards & Security

## TypeScript
- Strict mode enabled, no `any` types
- Use type inference where possible
- Prefer interfaces for public APIs, types for unions/intersections
- Always type function parameters and return types

## React/Next.js
- Server Components by default, use 'use client' only when necessary
- Prefer Server Actions over API routes for mutations
- Use async/await for all async operations
- Error boundaries on all major sections
- Proper loading states and error handling

## Security
- Zod validation on ALL user inputs (API routes, Server Actions, forms)
- Rate limiting on API routes (use middleware)
- CSRF protection via NextAuth
- Sanitize HTML content in descriptions (DOMPurify or similar)
- Never expose sensitive data in client components
- Use environment variables for all secrets
- Hash passwords with bcrypt (minimum 10 rounds)
- Validate file uploads (type, size, content)

## Code Quality
- Clean, readable code over clever solutions
- Meaningful variable and function names
- Single responsibility principle
- DRY but don't over-abstract
- Comment complex logic, not obvious code
- Consistent formatting (Prettier)

## Database
- Use Prisma for all DB operations
- Transactions for multi-step operations
- Indexes on frequently queried fields
- Soft deletes where appropriate (active flag)
- Proper error handling for DB operations

## API Design
- RESTful conventions
- Consistent error responses
- Proper HTTP status codes
- Rate limiting on public endpoints
- CORS configured correctly

## Logging
- Use structured logging (pino)
- Log errors with context
- Don't log sensitive data
- Appropriate log levels (error, warn, info, debug)

## Testing
- **OBLIGATORIU:** Creează teste pentru fiecare funcționalitate nouă
- Unit tests pentru utilities (sanitize, rate-limit, etc.)
- Integration tests pentru API routes și Server Actions
- E2E tests pentru flow-uri critice (viitor)

### Procedura Testare Automată

**După fiecare funcționalitate nouă:**

1. **Identifică ce trebuie testat:**
   - Funcții pure (utilities) → `tests/unit/nume-functionalitate.test.ts`
   - Integrări (API routes, Server Actions) → `tests/integration/nume-functionalitate.test.ts`
   - Componente React → `tests/components/nume-component.test.tsx` (viitor)

2. **Creează fișier de test:**
   ```typescript
   import { describe, it, expect } from 'vitest'
   import { functieDeTestat } from '@/path/to/function'
   
   describe('nume functionalitate', () => {
     it('should work correctly', () => {
       expect(functieDeTestat(input)).toBe(expectedOutput)
     })
     
     it('should handle edge case', () => {
       // test edge case
     })
     
     it('should handle errors', () => {
       // test error handling
     })
   })
   ```

3. **Rulează testele:**
   - `npm test -- tests/unit/nume-functionalitate.test.ts`
   - Verifică că toate testele trec

4. **Commit:**
   - `git add tests/`
   - `git commit -m "test: add tests for nume-functionalitate"`

**Teste la build:**
- Testele rulează automat la `npm run build:test`
- Dacă testele eșuează → build-ul eșuează → nu se deploy-ează

**Best Practices:**
- Testează comportamentul, nu implementarea
- Testează edge cases și error handling
- Un test = o singură verificare
- Folosește date de test realiste
- Nu ignora testele care eșuează

## Performance
- Optimize images (Next.js Image component)
- Lazy load components where appropriate
- Database query optimization
- Cache static data appropriately

